# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_GWFrames', [dirname(__file__)])
        except ImportError:
            import _GWFrames
            return _GWFrames
        if fp is not None:
            try:
                _mod = imp.load_module('_GWFrames', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _GWFrames = swig_import_helper()
    del swig_import_helper
else:
    import _GWFrames
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _GWFrames.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self): return _GWFrames.SwigPyIterator_value(self)
    def incr(self, n=1): return _GWFrames.SwigPyIterator_incr(self, n)
    def decr(self, n=1): return _GWFrames.SwigPyIterator_decr(self, n)
    def distance(self, *args): return _GWFrames.SwigPyIterator_distance(self, *args)
    def equal(self, *args): return _GWFrames.SwigPyIterator_equal(self, *args)
    def copy(self): return _GWFrames.SwigPyIterator_copy(self)
    def next(self): return _GWFrames.SwigPyIterator_next(self)
    def __next__(self): return _GWFrames.SwigPyIterator___next__(self)
    def previous(self): return _GWFrames.SwigPyIterator_previous(self)
    def advance(self, *args): return _GWFrames.SwigPyIterator_advance(self, *args)
    def __eq__(self, *args): return _GWFrames.SwigPyIterator___eq__(self, *args)
    def __ne__(self, *args): return _GWFrames.SwigPyIterator___ne__(self, *args)
    def __iadd__(self, *args): return _GWFrames.SwigPyIterator___iadd__(self, *args)
    def __isub__(self, *args): return _GWFrames.SwigPyIterator___isub__(self, *args)
    def __add__(self, *args): return _GWFrames.SwigPyIterator___add__(self, *args)
    def __sub__(self, *args): return _GWFrames.SwigPyIterator___sub__(self, *args)
    def __iter__(self): return self
SwigPyIterator_swigregister = _GWFrames.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

import Quaternions
import SphericalFunctions
## We have to be able to import numpy
import numpy;

## We have to be able to import Quaternions
import Quaternions

## We do not necessarily need spinsfast
try :
  import spinsfast
except ImportError :
  pass


def Unwrap(*args):
  return _GWFrames.Unwrap(*args)
Unwrap = _GWFrames.Unwrap

def ScalarIntegral(*args):
  """
    Integrate scalar function by simple trapezoidal rule.
    =====================================================
      Parameters
      ----------
        const vector<double>& fdot
          Vector of scalars.
        const vector<double>& t
          Vector of corresponding time steps.
      
      Returns
      -------
        vector<double>
      

    """
  return _GWFrames.ScalarIntegral(*args)

def CumulativeScalarIntegral(*args):
  return _GWFrames.CumulativeScalarIntegral(*args)
CumulativeScalarIntegral = _GWFrames.CumulativeScalarIntegral

def ScalarDerivative(*args):
  return _GWFrames.ScalarDerivative(*args)
ScalarDerivative = _GWFrames.ScalarDerivative

def ComplexDerivative(*args):
  return _GWFrames.ComplexDerivative(*args)
ComplexDerivative = _GWFrames.ComplexDerivative

def VectorIntegral(*args):
  return _GWFrames.VectorIntegral(*args)
VectorIntegral = _GWFrames.VectorIntegral

def CumulativeVectorIntegral(*args):
  return _GWFrames.CumulativeVectorIntegral(*args)
CumulativeVectorIntegral = _GWFrames.CumulativeVectorIntegral

def Intersection(*args):
  return _GWFrames.Intersection(*args)
Intersection = _GWFrames.Intersection

def Union(*args):
  return _GWFrames.Union(*args)
Union = _GWFrames.Union
class Matrix(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Matrix, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Matrix, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _GWFrames.new_Matrix(*args)
        try: self.this.append(this)
        except: self.this = this
    def __sub__(self, *args): return _GWFrames.Matrix___sub__(self, *args)
    def __call__(self, *args): return _GWFrames.Matrix___call__(self, *args)
    def set(self, *args): return _GWFrames.Matrix_set(self, *args)
    def nrows(self): return _GWFrames.Matrix_nrows(self)
    def ncols(self): return _GWFrames.Matrix_ncols(self)
    def resize(self, *args): return _GWFrames.Matrix_resize(self, *args)
    def clear(self): return _GWFrames.Matrix_clear(self)
    def swap(self, *args): return _GWFrames.Matrix_swap(self, *args)
    __swig_destroy__ = _GWFrames.delete_Matrix
    __del__ = lambda self : None;
    def __mul__(self, *args): return _GWFrames.Matrix___mul__(self, *args)
    def gslobj(self, *args): return _GWFrames.Matrix_gslobj(self, *args)
    def __repr__(self):
        return "".join(
                       [  'Matrix(['+repr([self(0,c) for c in range(self.ncols())])+',\n']
                       + ['        '+repr([self(r,c) for c in range(self.ncols())])+',\n' for r in range(1,self.nrows()-1)]
                       + ['        '+repr([self(r,c) for c in range(self.ncols()) for r in [self.nrows()-1]])+'])'] )

Matrix_swigregister = _GWFrames.Matrix_swigregister
Matrix_swigregister(Matrix)


def DominantPrincipalAxis(*args):
  return _GWFrames.DominantPrincipalAxis(*args)
DominantPrincipalAxis = _GWFrames.DominantPrincipalAxis

def Eigenvalues(*args):
  return _GWFrames.Eigenvalues(*args)
Eigenvalues = _GWFrames.Eigenvalues

def Eigenvectors(*args):
  return _GWFrames.Eigenvectors(*args)
Eigenvectors = _GWFrames.Eigenvectors

def Eigensystem(*args):
  return _GWFrames.Eigensystem(*args)
Eigensystem = _GWFrames.Eigensystem

def Determinant(*args):
  return _GWFrames.Determinant(*args)
Determinant = _GWFrames.Determinant
class MatrixC(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MatrixC, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MatrixC, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        this = _GWFrames.new_MatrixC(*args)
        try: self.this.append(this)
        except: self.this = this
    def swap(self, *args): return _GWFrames.MatrixC_swap(self, *args)
    def nrows(self): return _GWFrames.MatrixC_nrows(self)
    def ncols(self): return _GWFrames.MatrixC_ncols(self)
    def resize(self, *args): return _GWFrames.MatrixC_resize(self, *args)
    def assign(self, *args): return _GWFrames.MatrixC_assign(self, *args)
    __swig_destroy__ = _GWFrames.delete_MatrixC
    __del__ = lambda self : None;
MatrixC_swigregister = _GWFrames.MatrixC_swigregister
MatrixC_swigregister(MatrixC)

class vectorM(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorM, name)
    __repr__ = _swig_repr
    def iterator(self): return _GWFrames.vectorM_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _GWFrames.vectorM___nonzero__(self)
    def __bool__(self): return _GWFrames.vectorM___bool__(self)
    def __len__(self): return _GWFrames.vectorM___len__(self)
    def pop(self): return _GWFrames.vectorM_pop(self)
    def __getslice__(self, *args): return _GWFrames.vectorM___getslice__(self, *args)
    def __setslice__(self, *args): return _GWFrames.vectorM___setslice__(self, *args)
    def __delslice__(self, *args): return _GWFrames.vectorM___delslice__(self, *args)
    def __delitem__(self, *args): return _GWFrames.vectorM___delitem__(self, *args)
    def __getitem__(self, *args): return _GWFrames.vectorM___getitem__(self, *args)
    def __setitem__(self, *args): return _GWFrames.vectorM___setitem__(self, *args)
    def append(self, *args): return _GWFrames.vectorM_append(self, *args)
    def empty(self): return _GWFrames.vectorM_empty(self)
    def size(self): return _GWFrames.vectorM_size(self)
    def clear(self): return _GWFrames.vectorM_clear(self)
    def swap(self, *args): return _GWFrames.vectorM_swap(self, *args)
    def get_allocator(self): return _GWFrames.vectorM_get_allocator(self)
    def begin(self): return _GWFrames.vectorM_begin(self)
    def end(self): return _GWFrames.vectorM_end(self)
    def rbegin(self): return _GWFrames.vectorM_rbegin(self)
    def rend(self): return _GWFrames.vectorM_rend(self)
    def pop_back(self): return _GWFrames.vectorM_pop_back(self)
    def erase(self, *args): return _GWFrames.vectorM_erase(self, *args)
    def __init__(self, *args): 
        this = _GWFrames.new_vectorM(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _GWFrames.vectorM_push_back(self, *args)
    def front(self): return _GWFrames.vectorM_front(self)
    def back(self): return _GWFrames.vectorM_back(self)
    def assign(self, *args): return _GWFrames.vectorM_assign(self, *args)
    def resize(self, *args): return _GWFrames.vectorM_resize(self, *args)
    def insert(self, *args): return _GWFrames.vectorM_insert(self, *args)
    def reserve(self, *args): return _GWFrames.vectorM_reserve(self, *args)
    def capacity(self): return _GWFrames.vectorM_capacity(self)
    __swig_destroy__ = _GWFrames.delete_vectorM
    __del__ = lambda self : None;
vectorM_swigregister = _GWFrames.vectorM_swigregister
vectorM_swigregister(vectorM)

UnknownFrameType = _GWFrames.UnknownFrameType
Inertial = _GWFrames.Inertial
Aligned = _GWFrames.Aligned
Coorbital = _GWFrames.Coorbital
Corotating = _GWFrames.Corotating
UnknownDataType = _GWFrames.UnknownDataType
h = _GWFrames.h
hdot = _GWFrames.hdot
Psi4 = _GWFrames.Psi4
class Waveform(_object):
    """
    class GWFrames::Waveform
    ========================
      Object storing data and other information for a single waveform.
      
      Member variables
      ----------------
        int spinweight
        int boostweight
        stringstream history
        vector<double> t
        vector<Quaternions::Quaternion> frame
        WaveformFrameType frameType
        WaveformDataType dataType
        bool rIsScaledOut
        bool mIsScaledOut
        vector<vector<int>> lm
        MatrixC data
      
      Non-public member functions
      ---------------------------
        Waveform& TransformModesToRotatedFrame
          Rotate modes of the Waveform object.    Waveform& TransformUncertaintiesToRotatedFrame
          Rotate modes of the uncertainty of a Waveform object.  

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Waveform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Waveform, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Default constructor for an empty object.
        ========================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          

        Copy constructor.
        =================
          Parameters
          ----------
            const Waveform& W
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            Simply copies all fields in the input object to the constructed object,
            including history
          

        Constructor from data file.
        ===========================
          Parameters
          ----------
            const string& FileName
              Relative path to data file
            const string& DataFormat
              Either 'ReIm' or 'MagArg'
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            NOTE: This function assumes that the data are stored as (ell,m) modes,
            starting with (2,-2), incrementing m, then incrementing ell and starting
            again at m=-ell. If this is not how the modes are stored, the 'lm' data of
            this object needs to be reset or bad things will happen when trying to find
            the angular-momentum vector or rotate the waveform.
          

        Explicit constructor from data.
        ===============================
          Parameters
          ----------
            const vector<double>& T
            const vector<vector<int>>& LM
            const vector<vector<complex<double>>>& Data
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            Arguments are T, LM, Data, which consist of the explicit data.
          

        """
        this = _GWFrames.new_Waveform(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _GWFrames.delete_Waveform
    __del__ = lambda self : None;
    def SetSpinWeight(self, *args):
        """
        Parameters
        ----------
          const int NewSpinWeight

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetSpinWeight(self, *args)

    def SetBoostWeight(self, *args):
        """
        Parameters
        ----------
          const int NewBoostWeight

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetBoostWeight(self, *args)

    def AppendHistory(self, *args):
        """
        Parameters
        ----------
          const string& Hist

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_AppendHistory(self, *args)

    def SetHistory(self, *args):
        """
        Parameters
        ----------
          const string& Hist

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetHistory(self, *args)

    def SetT(self, *args):
        """
        Parameters
        ----------
          const vector<double>& a

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetT(self, *args)

    def SetTime(self, *args):
        """
        Parameters
        ----------
          const vector<double>& a

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetTime(self, *args)

    def SetFrame(self, *args):
        """
        Parameters
        ----------
          const vector<Quaternions::Quaternion>& a

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetFrame(self, *args)

    def SetFrameType(self, *args):
        """
        Parameters
        ----------
          const WaveformFrameType Type

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetFrameType(self, *args)

    def SetDataType(self, *args):
        """
        Parameters
        ----------
          const WaveformDataType Type

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetDataType(self, *args)

    def SetRIsScaledOut(self, *args):
        """
        Parameters
        ----------
          const bool Scaled

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetRIsScaledOut(self, *args)

    def SetMIsScaledOut(self, *args):
        """
        Parameters
        ----------
          const bool Scaled

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetMIsScaledOut(self, *args)

    def SetLM(self, *args):
        """
        Parameters
        ----------
          const vector<vector<int>>& a

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetLM(self, *args)

    def SetData(self, *args):
        """
        Parameters
        ----------
          const vector<vector<complex<double>>>& a

        Returns
        -------
          void




        Parameters
        ----------
          const unsigned int i_Mode
          const unsigned int i_Time
          const complex<double>& a

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_SetData(self, *args)

    def ResizeData(self, *args):
        """
        Parameters
        ----------
          const unsigned int NModes
          const unsigned int NTimes

        Returns
        -------
          void


        """
        return _GWFrames.Waveform_ResizeData(self, *args)

    def swap(self, *args):
        """
        Efficiently swap data between two Waveform objects.
        ===================================================
          Parameters
          ----------
            Waveform& b
          
          Returns
          -------
            void
          
          Description
          -----------
            This function uses the std::vector method 'swap' which simply swaps
            pointers to data, for efficiency.
          

        """
        return _GWFrames.Waveform_swap(self, *args)

    def NTimes(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          unsigned int


        """
        return _GWFrames.Waveform_NTimes(self)

    def NModes(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          unsigned int


        """
        return _GWFrames.Waveform_NModes(self)

    def SpinWeight(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          int


        """
        return _GWFrames.Waveform_SpinWeight(self)

    def BoostWeight(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          int


        """
        return _GWFrames.Waveform_BoostWeight(self)

    def HistoryStr(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          string


        """
        return _GWFrames.Waveform_HistoryStr(self)

    def HistoryStream(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          stringstream&


        """
        return _GWFrames.Waveform_HistoryStream(self)

    def FrameType(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          int


        """
        return _GWFrames.Waveform_FrameType(self)

    def DataType(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          int


        """
        return _GWFrames.Waveform_DataType(self)

    def FrameTypeString(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          string


        """
        return _GWFrames.Waveform_FrameTypeString(self)

    def DataTypeString(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          string


        """
        return _GWFrames.Waveform_DataTypeString(self)

    def DataTypeLaTeXString(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          string


        """
        return _GWFrames.Waveform_DataTypeLaTeXString(self)

    def DescriptorString(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          string


        """
        return _GWFrames.Waveform_DescriptorString(self)

    def RIsScaledOut(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          bool


        """
        return _GWFrames.Waveform_RIsScaledOut(self)

    def MIsScaledOut(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          bool


        """
        return _GWFrames.Waveform_MIsScaledOut(self)

    def __call__(self, *args):
        """
        Parameters
        ----------
          const unsigned int Mode
          const unsigned int TimeIndex

        Returns
        -------
          complex<double>


        """
        return _GWFrames.Waveform___call__(self, *args)

    def T(self, *args):
        """
        Parameters
        ----------
          const unsigned int TimeIndex

        Returns
        -------
          double




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<double>&


        """
        val = _GWFrames.Waveform_T(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Frame(self, *args):
        """
        Parameters
        ----------
          const unsigned int TimeIndex

        Returns
        -------
          Quaternions::Quaternion




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<Quaternions::Quaternion>&


        """
        val = _GWFrames.Waveform_Frame(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def LM(self, *args):
        """
        Parameters
        ----------
          const unsigned int Mode

        Returns
        -------
          const vector<int>&




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<vector<int>>&


        """
        val = _GWFrames.Waveform_LM(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Re(self, *args):
        """
        Parameters
        ----------
          const unsigned int Mode
          const unsigned int TimeIndex

        Returns
        -------
          double


        turn vector of real parts of a given mode as function of time.
        ==============================================================
        Parameters
        ----------
          const unsigned int Mode

        Returns
        -------
          vector<double>


        turn vector of vector of real parts of all modes as function of time.
        =====================================================================
        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.Waveform_Re(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Im(self, *args):
        """
        Parameters
        ----------
          const unsigned int Mode
          const unsigned int TimeIndex

        Returns
        -------
          double


        turn vector of imaginary parts of a given mode as function of time.
        ===================================================================
        Parameters
        ----------
          const unsigned int Mode

        Returns
        -------
          vector<double>


        turn vector of vector of imaginary parts of all modes as function of time.
        ==========================================================================
        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.Waveform_Im(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Abs(self, *args):
        """
        Parameters
        ----------
          const unsigned int Mode
          const unsigned int TimeIndex

        Returns
        -------
          double


        turn vector of absolute value of a given mode as function of time.
        ==================================================================
        Parameters
        ----------
          const unsigned int Mode

        Returns
        -------
          vector<double>


        turn vector of vector of absolute value of all modes as function of time.
        =========================================================================
        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.Waveform_Abs(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Arg(self, *args):
        """
        Parameters
        ----------
          const unsigned int Mode
          const unsigned int TimeIndex

        Returns
        -------
          double


        turn vector of arg of a given mode as function of time.
        =======================================================
        Parameters
        ----------
          const unsigned int Mode

        Returns
        -------
          vector<double>

        Description
        -----------
          Note that this quantity is not 'unwrapped'. That is, the arg is between -pi
          and +pi. To get a smooth, continuous phase in python, use numpy.unwrap.


        turn vector of vector of arg of all modes as function of time.
        ==============================================================
        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.Waveform_Arg(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def ArgUnwrapped(self, *args):
        """
        Parameters
        ----------
          const unsigned int Mode

        Returns
        -------
          vector<double>


        turn vector of vector of arg of all modes as function of time.
        ==============================================================
        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.Waveform_ArgUnwrapped(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Data(self, *args):
        """
        Parameters
        ----------
          const unsigned int Mode
          const unsigned int TimeIndex

        Returns
        -------
          complex<double>


        turn vector of complex data of a given mode as function of time.
        ================================================================
        Parameters
        ----------
          const unsigned int Mode

        Returns
        -------
          vector<complex<double>>


        turn vector of vector of complex data of all modes as function of time.
        =======================================================================
        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<complex<double>>>


        """
        val = _GWFrames.Waveform_Data(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def EllMax(self):
        """
        Return greatest ell value present in the data.
        ==============================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            int
          

        """
        return _GWFrames.Waveform_EllMax(self)

    def FindModeIndex(self, *args):
        """
        Find index of mode with given (l,m) data.
        =========================================
          Parameters
          ----------
            const int L
            const int M
          
          Returns
          -------
            unsigned int
          

        """
        return _GWFrames.Waveform_FindModeIndex(self, *args)

    def FindModeIndexWithoutError(self, *args):
        """
        Find index of mode with given (l,m) data without the chance of throwing an exception.
        =====================================================================================
          Parameters
          ----------
            const int L
            const int M
          
          Returns
          -------
            unsigned int
          
          Description
          -----------
            If the requested mode is not present, the returned index is 1 beyond the
            end of the mode vector.
          

        """
        return _GWFrames.Waveform_FindModeIndexWithoutError(self, *args)

    def DataDot(self, *args):
        """
        Return time derivative of data.
        ===============================
          Parameters
          ----------
            const unsigned int Mode
          
          Returns
          -------
            vector<complex<double>>
          

        """
        return _GWFrames.Waveform_DataDot(self, *args)

    def Norm(self, TakeSquareRoot=False):
        """
        Return the norm (sum of squares of modes) of the waveform.
        ==========================================================
          Parameters
          ----------
            const bool TakeSquareRoot = false
              If true, the square root is taken at each instant before returning
          
          Returns
          -------
            vector<double>
          
          Description
          -----------
            This returns the norm of the waveform, defined as the sum of the complex
            norms of the modes. Note that we are calling this norm in analogy with the
            c++ std::complex norm, which is the square of the absolute value. However,
            there is also an option to take the square root of the data at each time
            step, which would be the usual L2 norm of the waveform.
            
            MaxNormIndex
            
            MaxNormTime
          

        """
        val = _GWFrames.Waveform_Norm(self, TakeSquareRoot)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def MaxNormIndex(self, SkipFraction=4):
        """
        Return the data index corresponding to the time of the largest norm.
        ====================================================================
          Parameters
          ----------
            const unsigned int SkipFraction = 4
              Integer fraction of data to skip before looking
          
          Returns
          -------
            unsigned int
          
          Description
          -----------
            The default value of SkipFraction is 4, meaning that we start looking for
            the maximum after 1/4th of the data, so as to cut out junk radiation. Note
            that this is integer division, so an argument of NTimes()+1 will look
            through all of the data.
            
            Norm()
            
            MaxNormTime()
          

        """
        return _GWFrames.Waveform_MaxNormIndex(self, SkipFraction)

    def MaxNormTime(self, SkipFraction=4):
        """
        Parameters
        ----------
          const unsigned int SkipFraction = 4

        Returns
        -------
          double


        """
        return _GWFrames.Waveform_MaxNormTime(self, SkipFraction)

    def RotatePhysicalSystem(self, *args):
        """
        Rotate the physical content of the Waveform by a constant rotor.
        ================================================================
          Parameters
          ----------
            const Quaternions::Quaternion& R_phys
          
          Returns
          -------
            Waveform&
          

        Rotate the physical content of the Waveform.
        ============================================
          Parameters
          ----------
            vector<Quaternions::Quaternion> R_phys
              Vector of Quaternions by which to rotate
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This rotates the physical system, leaving the coordinates in place.
            
            The Waveform's frame data records the rotors needed to rotate the standard
            (x,y,z) basis into the (X,Y,Z) basis with respect to which the Waveform
            modes are decomposed. If this is not the first rotation of the frame, we
            need to be careful about how we record the total rotation. Here, we are
            rotating the physical system, while leaving fixed the basis with respect to
            which the modes are decomposed. Therefore, the new frame must be the
            original frame data times $\bar{R}_{phys}$.
            
            Note that this function does not change the frameType; this is left to the
            calling function.
          

        """
        return _GWFrames.Waveform_RotatePhysicalSystem(self, *args)

    def RotateDecompositionBasis(self, *args):
        """
        Rotate the basis in which this Waveform is measured by a constant rotor.
        ========================================================================
          Parameters
          ----------
            const Quaternions::Quaternion& R_frame
          
          Returns
          -------
            Waveform&
          

        Rotate the basis in which this Waveform is measured.
        ====================================================
          Parameters
          ----------
            const vector<Quaternions::Quaternion>& R_frame
              Vector of Quaternions by which to rotate
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This rotates the coordinate basis, leaving the physical system in place.
            
            The Waveform's frame data records the rotors needed to rotate the standard
            (x,y,z) basis into the (X,Y,Z) basis with respect to which the Waveform
            modes are decomposed. If this is not the first rotation of the frame, we
            need to be careful about how we record the total rotation. Here, we are
            just composing rotations, so we need to store R_frame times the original
            frame data.
            
            Note that this function does not change the frameType; this is left to the
            calling function.
          

        """
        return _GWFrames.Waveform_RotateDecompositionBasis(self, *args)

    def RotateDecompositionBasisOfUncertainties(self, *args):
        """
        Rotate the basis in which this Waveform's uncertainties are measured.
        =====================================================================
          Parameters
          ----------
            const vector<Quaternions::Quaternion>& R_frame
              Vector of Quaternions by which to rotate
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This rotates the coordinate basis, leaving the physical system in place.
            
            The Waveform's frame data records the rotors needed to rotate the standard
            (x,y,z) basis into the (X,Y,Z) basis with respect to which the Waveform
            modes are decomposed. If this is not the first rotation of the frame, we
            need to be careful about how we record the total rotation. Here, we are
            just composing rotations, so we need to store R_frame times the original
            frame data.
            
            Note that this function does not change the frameType; this is left to the
            calling function.
          

        """
        return _GWFrames.Waveform_RotateDecompositionBasisOfUncertainties(self, *args)

    def LdtVector(self, *args):
        """
        Calculate the $<L \partial_t>$ quantity defined in the paper.
        ==============================================================
          Parameters
          ----------
            vector<int> Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            vector<vector<double>>
          
          Description
          -----------
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
            
            $<L \partial_t>^a = \sum_{\ell,m,m'} \Im [ \bar{f}^{\ell,m'}
            <\ell,m' | L_a | \ell,m> \dot{f}^{\ell,m} ]$
          

        """
        val = _GWFrames.Waveform_LdtVector(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def LLMatrix(self, *args):
        """
        Calculate the $<LL>$ quantity defined in the paper.
        ===================================================
          Parameters
          ----------
            vector<int> Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            vector<Matrix>
          
          Description
          -----------
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
            
            $<LL>^{ab} = \sum_{\ell,m,m'} [\bar{f}^{\ell,m'} <\ell,m' | L_a L_b |
            \ell,m> f^{\ell,m} ]$
          

        """
        val = _GWFrames.Waveform_LLMatrix(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def SchmidtEtAlVector(self, alpha0Guess=0.0, beta0Guess=0.0):
        """
        Parameters
        ----------
          const double alpha0Guess = 0.0
          const double beta0Guess = 0.0

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.Waveform_SchmidtEtAlVector(self, alpha0Guess, beta0Guess)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def OShaughnessyEtAlVector(self, *args):
        """
        Calculate the principal axis of the LL matrix, as prescribed by O'Shaughnessy et al.
        ====================================================================================
          Parameters
          ----------
            const vector<int>& Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            vector<vector<double>>
          
          Description
          -----------
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
          

        """
        val = _GWFrames.Waveform_OShaughnessyEtAlVector(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def AngularVelocityVector(self, *args):
        """
        Calculate the angular velocity of the Waveform.
        ===============================================
          Parameters
          ----------
            const vector<int>& Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            vector<vector<double>>
          
          Description
          -----------
            This returns the angular velocity of the Waveform, as defined in Sec. II of
            'Angular velocity of gravitational radiation and the corotating frame'.
            Note that the returned vector is relative to the inertial frame.
            
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
          

        """
        val = _GWFrames.Waveform_AngularVelocityVector(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def CorotatingFrame(self, *args):
        """
        Frame in which the rotation is minimal.
        =======================================
          Parameters
          ----------
            const vector<int>& Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            vector<Quaternions::Quaternion>
          
          Description
          -----------
            This function combines the steps required to obtain the corotating frame.
            
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
          

        """
        val = _GWFrames.Waveform_CorotatingFrame(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def PNEquivalentOrbitalAV(self, *args):
        """
        Deduce PN-equivalent orbital angular velocity from Waveform.
        ============================================================
          Parameters
          ----------
            const vector<int>& Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            vector<vector<double>>
          
          Description
          -----------
            This function simply takes the projection of the field's angular-velocity
            vector $\vec{\omega}$ along the dominant eigenvector $\hat{V}_f$ of
            $<LL>$. This should be equivalent to the orbital angular velocity of the PN
            system. Note that the returned vector is relative to the inertial frame.
            
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
          

        """
        val = _GWFrames.Waveform_PNEquivalentOrbitalAV(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def PNEquivalentPrecessionalAV(self, *args):
        """
        Deduce PN-equivalent precessional angular velocity from Waveform.
        =================================================================
          Parameters
          ----------
            const vector<int>& Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            vector<vector<double>>
          
          Description
          -----------
            This function subtracts the PN-equivalent orbital angular velocity (given
            by PNEquivalentOrbitalAV) from the field's angular velocity. This should be
            equivalent to the precessional angular velocity of the PN system. Note that
            the returned vector is relative to the inertial frame.
            
            This may be essentially numerical noise if there is no precession, or if
            precession has oscillated to zero.
            
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
            
            PNEquivalentOrbitalAV
          

        """
        val = _GWFrames.Waveform_PNEquivalentPrecessionalAV(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def TransformToSchmidtEtAlFrame(self, alpha0Guess=0.0, beta0Guess=0.0):
        """
        Transform Waveform to Schmidt et al. frame.
        ===========================================
          Parameters
          ----------
            const double alpha0Guess = 0.0
              Initial guess for optimal direction alpha
            const double beta0Guess = 0.0
              Initial guess for optimal direction beta
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This function combines the steps required to obtain the Waveform in the
            Schmidt et al. frame.
          

        """
        return _GWFrames.Waveform_TransformToSchmidtEtAlFrame(self, alpha0Guess, beta0Guess)

    def TransformToOShaughnessyEtAlFrame(self, *args):
        """
        Transform Waveform to O'Shaughnessy et al. frame.
        =================================================
          Parameters
          ----------
            const vector<int>& Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This function combines the steps required to obtain the Waveform in the
            O'Shaughnessy et al. frame.
            
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
          

        """
        return _GWFrames.Waveform_TransformToOShaughnessyEtAlFrame(self, *args)

    def TransformToAngularVelocityFrame(self, *args):
        """
        Transform Waveform to frame aligned with angular-velocity vector.
        =================================================================
          Parameters
          ----------
            const vector<int>& Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This function combines the steps required to obtain the Waveform in the
            frame aligned with the angular-velocity vector. Note that this frame is not
            the corotating frame; this frame has its z axis aligned with the
            angular-velocity vector.
            
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
          

        """
        return _GWFrames.Waveform_TransformToAngularVelocityFrame(self, *args)

    def TransformToCorotatingFrame(self, *args):
        """
        Transform Waveform to corotating frame.
        =======================================
          Parameters
          ----------
            const vector<int>& Lmodes = vector<int>(0)
              L modes to evaluate
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This function combines the steps required to obtain the Waveform in the
            corotating frame. Note that this leaves an integration constant unset. To
            set it, the modes should be rotated so that they are aligned with the frame
            using AlignModesToFrame.
            
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
          

        """
        return _GWFrames.Waveform_TransformToCorotatingFrame(self, *args)

    def TransformToInertialFrame(self):
        """
        Transform Waveform to an inertial frame.
        ========================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This function uses the stored frame information to transform from whatever
            rotating frame the waveform is currently in, to a stationary, inertial
            frame. This is the usual frame of scri^+, and is the frame in which GW
            observations should be made.
          

        """
        return _GWFrames.Waveform_TransformToInertialFrame(self)

    def TransformUncertaintiesToCorotatingFrame(self, *args):
        """
        Transform Waveform uncertainties to corotating frame.
        =====================================================
          Parameters
          ----------
            const vector<Quaternions::Quaternion>& R_frame
              Vector of rotors giving corotating frame of the data.
          
          Returns
          -------
            Waveform&
          

        """
        return _GWFrames.Waveform_TransformUncertaintiesToCorotatingFrame(self, *args)

    def TransformUncertaintiesToInertialFrame(self):
        """
        Transform Waveform to an inertial frame.
        ========================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            This function uses the stored frame information to transform from whatever
            rotating frame the waveform is currently in, to a stationary, inertial
            frame. This is the usual frame of scri^+, and is the frame in which GW
            observations should be made.
          

        """
        return _GWFrames.Waveform_TransformUncertaintiesToInertialFrame(self)

    def Interpolate(self, *args):
        """
        Interpolate the Waveform to a new set of time instants.
        =======================================================
          Parameters
          ----------
            const vector<double>& NewTime
          
          Returns
          -------
            Waveform
          

        """
        return _GWFrames.Waveform_Interpolate(self, *args)

    def Segment(self, *args):
        """
        Extract a segment of a Waveform.
        ================================
          Parameters
          ----------
            const unsigned int i1
              Index of initial time
            const unsigned int i2
              Index just beyond final time
          
          Returns
          -------
            Waveform
          

        """
        return _GWFrames.Waveform_Segment(self, *args)

    def GetAlignmentOfTime(self, *args):
        """
        Find the time offset aligning this waveform to the other at the fiducial time.
        ==============================================================================
          Parameters
          ----------
            const Waveform& A
              Fixed Waveform in inertial frame to which this Waveform is aligned
            const double t_fid
            double& deltat
              The value to be returned
          
          Returns
          -------
            void
          
          Description
          -----------
            This function simply finds the appropriate time offset, rather than
            applying it. This is called by AlignTime and probably does not need to be
            called directly; see that function's documentation for more details.
            
            AlignTime
          

        """
        return _GWFrames.Waveform_GetAlignmentOfTime(self, *args)

    def AlignTime(self, *args):
        """
        Change this Waveform by aligning to the other at the given time.
        ================================================================
          Parameters
          ----------
            const Waveform& A
              Fixed Waveform in inertial frame to which this Waveform is aligned
            const double t_fid
              Note that this function operates in place; the Waveform to which it is
              applied will change.
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            As noted above, it is implicitly assumed that both Waveforms are in an
            inertial frame, so that the magnitude of the angular velocity may be
            properly measured. This could be adjusted to account for the angular
            velocity of the frame, but hasn't been yet.
            
            To improve accuracy, the angular velocity of A is interpolated to t_fid.
            The time of B is then interpolated to the interpolated angular velocity.
            This assumes that B's angular velocity is strictly monotonic for roughly 5
            data points to either side.
          

        """
        return _GWFrames.Waveform_AlignTime(self, *args)

    def GetAlignmentOfDecompositionFrameToModes(self, *args):
        """
        Find the appropriate rotation to fix the orientation of the corotating frame.
        =============================================================================
          Parameters
          ----------
            const double t_fid
              Fiducial time at which the alignment should happen
            Quaternions::Quaternion& R_delta
              Returned rotor
            const vector<int>& Lmodes = vector<int>(0)
              Lmodes to use in computing $<LL>$
          
          Returns
          -------
            void
          
          Description
          -----------
            This function simply finds the rotation necessary to align the corotating
            frame to the waveform at the fiducial time, rather than applying it. This
            is called by AlignDecompositionFrameToModes and probably does not need to
            be called directly; see that function's documentation for more details.
            
            AlignDecompositionFrameToModes
          

        """
        return _GWFrames.Waveform_GetAlignmentOfDecompositionFrameToModes(self, *args)

    def AlignDecompositionFrameToModes(self, *args):
        """
        Fix the orientation of the corotating frame.
        ============================================
          Parameters
          ----------
            const double t_fid
              Fiducial time at which the alignment should happen
            const vector<int>& Lmodes = vector<int>(0)
              Lmodes to use in computing $<LL>$
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            The corotating frame is only defined up to some constant rotor R_c; if
            R_corot is corotating, then so is R_corot*R_c. This function uses that
            freedom to ensure that the frame is aligned with the Waveform modes at the
            fiducial time. In particular, it ensures that the Z axis of the frame in
            which the decomposition is done is along the dominant eigenvector of $<LL>$
            (suggested by O'Shaughnessy et al.), and the phase of the (2,2) mode is
            zero.
            
            If Lmodes is empty (default), all L modes are used. Setting Lmodes to [2]
            or [2,3,4], for example, restricts the range of the sum.
          

        """
        return _GWFrames.Waveform_AlignDecompositionFrameToModes(self, *args)

    def GetAlignmentOfFrame(self, *args):
        """
        Get the rotor needed to align this waveform's frame to the other's at the given time.
        =====================================================================================
          Parameters
          ----------
            const Waveform& A
              Fixed Waveform in corotating frame to which this Waveform is aligned
            const double t_fid
              Fiducial time at which to equate frames
            Quaternions::Quaternion& R_delta
              Returned rotor
          
          Returns
          -------
            void
          
          Description
          -----------
            This function simply finds the rotation necessary to align this waveform's
            frame to the other at the fiducial time, rather than applying it. This is
            called by AlignFrame and probably does not need to be called directly; see
            that function's documentation for more details.
            
            AlignFrame
          

        """
        return _GWFrames.Waveform_GetAlignmentOfFrame(self, *args)

    def AlignFrame(self, *args):
        """
        Change this Waveform by aligning the frame to the other's at the given time.
        ============================================================================
          Parameters
          ----------
            const Waveform& A
              Fixed Waveform in corotating frame to which this Waveform is aligned
            const double t_fid
              Fiducial time at which to equate frames
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            Note that this function operates in place; the Waveform to which it is
            applied will change. However, the modes are not altered; only the frame
            data is.
            
            As noted above, it is implicitly assumed that both Waveforms are in their
            corotating frames, with the modes appropriately aligned to the frames at
            t_fid. The assumption is that the frames actually represent something
            physically meaningful, so that it is meaningful to insist that they be the
            same.
            
            Then, this function aligns the frames at t_fid by multiplying this->frame
            on the left by a constant rotor such that this->frame at t_fid is exactly
            A.frame at t_fid. The resulting frame is now corotating with an
            angular-velocity vector that has been rotated by that constant rotor,
            relative to the inertial basis.
            
            AlignDecompositionFrameToModes
          

        """
        return _GWFrames.Waveform_AlignFrame(self, *args)

    def GetAlignmentOfTimeAndFrame(self, *args):
        """
        Get time and frame offset for alignment over extended region.
        =============================================================
          Parameters
          ----------
            const Waveform& A
              Fixed Waveform in corotating frame to which this Waveform is aligned
            const double t1
              Initial time of region over which differences are minimized
            const double t2
              Final time of region over which differences are minimized
            double& deltat
              Returned time offset
            Quaternions::Quaternion& R_delta
              Returned rotation offset
          
          Returns
          -------
            void
          
          Description
          -----------
            This function simply finds the time and rotation shifts necessary to align
            this waveform to the other at the fiducial time, rather than applying it.
            This is called by AlignTimeAndFrame and probably does not need to be called
            directly; see that function's documentation for more details.
            
            AlignTimeAndFrame
          

        """
        return _GWFrames.Waveform_GetAlignmentOfTimeAndFrame(self, *args)

    def AlignTimeAndFrame(self, *args):
        """
        Align time and frame over extended region.
        ==========================================
          Parameters
          ----------
            const Waveform& A
              Fixed Waveform in corotating frame to which this Waveform is aligned
            const double t1
              Initial time of region over which differences are minimized
            const double t2
              Final time of region over which differences are minimized
          
          Returns
          -------
            Waveform&
          
          Description
          -----------
            Note that this function operates in place; the Waveform to which it is
            applied will change. However, the modes are not altered; only the t and
            frame data are.
            
            As noted above, it is implicitly assumed that both Waveforms are in their
            corotating frames, with the modes appropriately aligned to the frames at
            t_fid. The assumption is that the frames actually represent something
            physically meaningful, so that it is meaningful to insist that they be the
            same.
            
            Then, this function adjust the time and orientation of this Waveform, so
            that the difference between the two frames is minimized. That difference is
            measured by finding the rotor R_Delta required to rotate one frame into the
            other, taking the angle of that rotor, and integrating over the region [t1,
            t2].
            
            Relative to the inertial basis, the physical measurables (angular-velocity
            vector and dominant eigenvector of $<LL>$) of this Waveform are rotated.
            
            AlignDecompositionFrameToModes
          

        """
        return _GWFrames.Waveform_AlignTimeAndFrame(self, *args)

    def Compare(self, *args):
        """
        Return a Waveform with differences between the two inputs.
        ==========================================================
          Parameters
          ----------
            const Waveform& B
            const double MinTimeStep = 0.005
            const double MinTime = -3.0e300
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This function simply subtracts the data in this Waveform from the data in
            Waveform A, and finds the rotation needed to take this frame into frame A.
            Note that the waveform data are stored as complex numbers, rather than as
            modulus and phase.
          

        """
        return _GWFrames.Waveform_Compare(self, *args)

    def Hybridize(self, *args):
        """
        Hybridize this Waveform with another.
        =====================================
          Parameters
          ----------
            const Waveform& B
              Second Waveform to hybridize with
            const double t1
              Beginning of time over which to transition
            const double t2
              End of time over which to transition
            const double tMinStep = 0.005
              Lower limit on time step appearing in the output
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This function simply takes two Waveforms and blends them together. In
            particular, it does not align the Waveforms; that is assumed to have been
            done already. The transition function is a smooth
            
            Note that this function does NOT operate in place; a new Waveform object is
            constructed and returned.
          

        """
        return _GWFrames.Waveform_Hybridize(self, *args)

    def EvaluateAtPoint(self, *args):
        """
        Evaluate Waveform at a particular sky location.
        ===============================================
          Parameters
          ----------
            const double vartheta
              Polar angle of detector
            const double varphi
              Azimuthal angle of detector
          
          Returns
          -------
            vector<complex<double>>
          
          Description
          -----------
            Note that the input angle parameters are measured relative to the binary's
            coordinate system. In particular, this will make no sense if the frame type
            is something other than inertial, and will fail if the FrameType is neither
            UnknownFrameType nor Inertial.
          

        """
        return _GWFrames.Waveform_EvaluateAtPoint(self, *args)

    def __add__(self, *args):
        """
        Parameters
        ----------
          const Waveform& B

        Returns
        -------
          Waveform


        """
        return _GWFrames.Waveform___add__(self, *args)

    def __sub__(self, *args):
        """
        Parameters
        ----------
          const Waveform& B

        Returns
        -------
          Waveform


        """
        return _GWFrames.Waveform___sub__(self, *args)

    def __mul__(self, *args):
        """
        Parameters
        ----------
          const Waveform& B

        Returns
        -------
          Waveform




        Parameters
        ----------
          const double b

        Returns
        -------
          Waveform


        """
        return _GWFrames.Waveform___mul__(self, *args)

    def __div__(self, *args):
        """
        Parameters
        ----------
          const Waveform& B

        Returns
        -------
          Waveform




        Parameters
        ----------
          const double b

        Returns
        -------
          Waveform


        """
        return _GWFrames.Waveform___div__(self, *args)

    def NPEdth(self):
        """
        Newman-Penrose edth operator.
        =============================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This operator is the one defined by Newman and Penrose (1966) and further
            described by Goldberg et al. (1967). It raises the spin weight of any field
            on the sphere by 1. Note that this operator does not preserve boost weights
            in any nice way  except in special cases. The GHP version does. Note that,
            in this implementation, the only difference between the NP and GHP versions
            is the factor of $\sqrt{2}$. The additional GHP term that keeps the boost
            weight meaningful is zero in any given frame  though it transforms
            nontrivially.
            
            Note that the boost weight is set to the value of WeightError, which is
            just meant to be large enough that it will give improbable values if used.
            This is not fool-proof.
            
            NPEdthBar
            
            GHPEdth
            
            GHPEdthBar
            
            IntegrateNPEdth
            
            IntegrateNPEdthBar
            
            IntegrateGHPEdth
            
            IntegrateGHPEdthBar
          

        """
        return _GWFrames.Waveform_NPEdth(self)

    def NPEdthBar(self):
        """
        Newman-Penrose edth operator conjugate.
        =======================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This operator is the one defined by Newman and Penrose (1966) and further
            described by Goldberg et al. (1967). It lowers the spin weight of any field
            on the sphere by 1. Note that this operator does not preserve boost weights
            in any nice way  except in special cases. The GHP version does. Note that,
            in this implementation, the only difference between the NP and GHP versions
            is the factor of $\sqrt{2}$. The additional GHP term that keeps the boost
            weight meaningful is zero in any given frame  though it transforms
            nontrivially.
            
            Note that the boost weight is set to the value of WeightError, which is
            just meant to be large enough that it will give improbable values if used.
            This is not fool-proof.
            
            NPEdth
            
            GHPEdth
            
            GHPEdthBar
            
            IntegrateNPEdth
            
            IntegrateNPEdthBar
            
            IntegrateGHPEdth
            
            IntegrateGHPEdthBar
          

        """
        return _GWFrames.Waveform_NPEdthBar(self)

    def GHPEdth(self):
        """
        Geroch-Held-Penrose edth operator.
        ==================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This operator is the one defined by Geroch et al. (1973). It raises the
            spin weight of any field on the sphere by 1, while leaving the boost weight
            unchanged.
            
            This operator is very similar to the basic Newman-Penrose edth operator,
            except that it preserves boost weights. Its effect in this implementation
            is identical (up to a factor of $\sqrt{2}$) to the NP edth. There is an
            additional term in the definition of the GHP operator, but its value is
            zero. (It transforms nontrivially, though.) In this context, we have
            NPEdth() = sqrt(2)*GHPEdth().
            
            The complex shear $\sigma$ has spin weight +2 and boost weight +1. The
            radial coordinate $r$ has boost weight -1, and the derivative with respect
            to time $d/du$ has boost weight -1. The asymptotic metric shear $r\, h$
            has spin weight -2 and boost weight -1. In particular, it seems that $r\,
            h = r^2\, \bar{\sigma}$.
            
            The Newman-Penrose scalars $\Psi_i$ have spin weight and boost weight
            equal to $2-i$. (E.g., $\Psi_4$ has $s = b = -2$.) However, when these are
            multiplied by the appropriate factors of $r$ to find the leading-order
            terms, they acquire boost weights. In particular, we need to multiply
            $\Psi_i$ by $r^{5-i}$ to get nonzero values at scri, which adds $i-5$ to
            the boost weight, so that the asymptotic NP scalars all have boost weight
            -3.
            
            NPEdth
            
            NPEdthBar
            
            GHPEdthBar
            
            IntegrateNPEdth
            
            IntegrateNPEdthBar
            
            IntegrateGHPEdth
            
            IntegrateGHPEdthBar
          

        """
        return _GWFrames.Waveform_GHPEdth(self)

    def GHPEdthBar(self):
        """
        Geroch-Held-Penrose edth operator conjugate.
        ============================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This operator is the one defined by Geroch et al. (1973). It lowers the
            spin weight of any field on the sphere by 1, while leaving the boost weight
            unchanged.
            
            This operator is very similar to the basic Newman-Penrose edth operator,
            except that it preserves boost weights. Its effect in this implementation
            is identical (up to a factor of $\sqrt{2}$) to the NP edth. There is an
            additional term in the definition of the GHP operator, but its value is
            zero. (It transforms nontrivially, though.) In this context, we have
            NPEdthBar() = sqrt(2)*GHPEdthBar().
            
            The complex shear $\sigma$ has spin weight +2 and boost weight +1. The
            radial coordinate $r$ has boost weight -1, and the derivative with respect
            to time $d/du$ has boost weight -1. The asymptotic metric shear $r\, h$
            has spin weight -2 and boost weight -1. In particular, it seems that $r\,
            h = r^2\, \bar{\sigma}$.
            
            The Newman-Penrose scalars $\Psi_i$ have spin weight and boost weight
            equal to $2-i$. (E.g., $\Psi_4$ has $s = b = -2$.) However, when these are
            multiplied by the appropriate factors of $r$ to find the leading-order
            terms, they acquire boost weights. In particular, we need to multiply
            $\Psi_i$ by $r^{5-i}$ to get nonzero values at scri, which adds $i-5$ to
            the boost weight, so that the asymptotic NP scalars all have boost weight
            -3.
            
            NPEdth
            
            NPEdthBar
            
            GHPEdth
            
            IntegrateNPEdth
            
            IntegrateNPEdthBar
            
            IntegrateGHPEdth
            
            IntegrateGHPEdthBar
          

        """
        return _GWFrames.Waveform_GHPEdthBar(self)

    def IntegrateNPEdth(self):
        """
        Integrate the Newman-Penrose edth operator.
        ===========================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This operator inverts the action of the Newman-Penrose edth operator. This
            is not a perfect inverse, because the l=s-1 term is set to zero. To be
            precise, if Waveform A has spin weight $s$, then
            A.NPEdth().IntegrateNPEdth() has the effect of setting the $\ell=s$ term
            in A to zero.
            
            Note that the N-P edth operator does not preserve boost weights, so the
            boost weight is set to the value of WeightError, which is just meant to be
            large enough that it will give improbable values if used. This is not
            fool-proof. See the GHP edth operator for a weight-preserving version.
            
            NPEdth
            
            NPEdthBar
            
            GHPEdth
            
            GHPEdthBar
            
            IntegrateNPEdthBar
            
            IntegrateGHPEdth
            
            IntegrateGHPEdthBar
          

        """
        return _GWFrames.Waveform_IntegrateNPEdth(self)

    def IntegrateNPEdthBar(self):
        """
        Integrate the Newman-Penrose edth operator conjugate.
        =====================================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This operator inverts the action of the conjugated Newman-Penrose edth
            operator. This is not a perfect inverse, because the l=s-1 term is set to
            zero. To be precise, if Waveform A has spin weight $s$, then
            A.NPEdthBar().IntegrateNPEdthBar() has the effect of setting the $\ell=s$
            term in A to zero.
            
            Note that the N-P edth operator does not preserve boost weights, so the
            boost weight is set to the value of WeightError, which is just meant to be
            large enough that it will give improbable values if used. This is not
            fool-proof. See the GHP edth operator for a weight-preserving version.
            
            NPEdth
            
            NPEdthBar
            
            GHPEdth
            
            GHPEdthBar
            
            IntegrateNPEdthBar
            
            IntegrateGHPEdth
            
            IntegrateGHPEdthBar
          

        """
        return _GWFrames.Waveform_IntegrateNPEdthBar(self)

    def IntegrateGHPEdth(self):
        """
        Integrate the Geroch-Held-Penrose edth operator.
        ================================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This operator inverts the action of the GHP edth operator. This is not a
            perfect inverse, because the l=s-1 term is set to zero. To be precise, if
            Waveform A has spins weight $s$, then A.GHPEdth().IntegrateGHPEdth() has
            the effect of setting the $\ell=s$ term in A to zero.
            
            NPEdth
            
            NPEdthBar
            
            GHPEdth
            
            GHPEdthBar
            
            IntegrateNPEdth
            
            IntegrateNPEdthBar
            
            IntegrateGHPEdthBar
          

        """
        return _GWFrames.Waveform_IntegrateGHPEdth(self)

    def IntegrateGHPEdthBar(self):
        """
        Integrate the Geroch-Held-Penrose edth operator conjugate.
        ==========================================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This operator inverts the action of the GHP edth operator. This is not a
            perfect inverse, because the l=s-1 term is set to zero. To be precise, if
            Waveform A has spins weight $s$, then A.GHPEdth().IntegrateGHPEdth() has
            the effect of setting the $\ell=s$ term in A to zero.
            
            NPEdth
            
            NPEdthBar
            
            GHPEdth
            
            GHPEdthBar
            
            IntegrateNPEdth
            
            IntegrateNPEdthBar
            
            IntegrateGHPEdth
          

        """
        return _GWFrames.Waveform_IntegrateGHPEdthBar(self)

    def ApplySupertranslation(self, *args):
        """
        Re-interpolate data to new time slices given by this supertranslation.
        ======================================================================
          Parameters
          ----------
            vector<complex<double>>& gamma
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This function takes the current data decomposed as spherical harmonics on a
            given slicing, transforms to physical space, re-interpolates the data at
            each point to a new set of time slices, and transforms back to
            spherical-harmonic coefficients.
            
            The supertranslation data input gamma is a vector of complex numbers
            representing the (scalar) spherical-harmonic components of the
            supertranslation, stored in the order (0,0), (1,-1), (1,0), (1,1), (2,-2),
            ... The overall time translation is given by the first component; the
            spatial translation is given by the second through fourth componentes;
            higher components give the proper supertranslations. In particular, a
            proper supertranslation will have its first four coefficients equal to 0.0.
            
            Note that, for general spin-weighted spherical-harmonic components
            ${}_{s}a_{l,m}$, a real function results when ${}_{-s}a_{l,-m} =
            {}_{s}a_{l,m}^\ast$. In particular, the input gamma data are assumed to
            satisfy this formula with $s=0$.
          

        """
        return _GWFrames.Waveform_ApplySupertranslation(self, *args)

    def Boost(self, *args):
        """
        Apply a boost to a boost-weighted function.
        ===========================================
          Parameters
          ----------
            const vector<double>& v
          
          Returns
          -------
            Waveform
          
          Description
          -----------
            This function does three things. First, it evaluates the Waveform on what
            will become an equi-angular grid after transformation by the boost. Second,
            it multiplies each of those points by the appropriate conformal factor
            $K^b(\vartheta, \varphi)$, where $b$ is the boost weight stored with the
            Waveform. Finally, it transforms back to Fourier space using that new
            equi-angular grid.
          

        """
        return _GWFrames.Waveform_Boost(self, *args)

    def Output(self, *args):
        """
        Output Waveform object to data file.
        ====================================
          Parameters
          ----------
            const string& FileName
            const unsigned int precision = 14
          
          Returns
          -------
            const Waveform&
          

        """
        return _GWFrames.Waveform_Output(self, *args)

    def HackSpECSignError(self):
        """
        Correct the error in RWZ extraction from older SpEC files.
        ==========================================================
          Parameters
          ----------
            (none)
          
          Returns
          -------
            Waveform&
          

        """
        return _GWFrames.Waveform_HackSpECSignError(self)

    def __str__(self): return _GWFrames.Waveform___str__(self)
    def __getstate__(self) :
      return (self.HistoryStr(),
              self.T(),
              self.Frame(),
              self.FrameType(),
              self.DataType(),
              self.RIsScaledOut(),
              self.MIsScaledOut(),
              self.LM(),
              self.Data()
              )
    __safe_for_unpickling__ = True
    def __reduce__(self) :
        return (Waveform, (), self.__getstate__())
    def __setstate__(self, data) :
        self.SetHistory(data[0])
        self.SetTime(data[1])
        self.SetFrame(data[2])
        self.SetFrameType(data[3])
        self.SetDataType(data[4])
        self.SetRIsScaledOut(data[5])
        self.SetMIsScaledOut(data[6])
        self.SetLM(data[7].tolist())
        self.SetData(data[8])

Waveform_swigregister = _GWFrames.Waveform_swigregister
Waveform_swigregister(Waveform)
constants = _GWFrames.constants
WaveformFrameNames = constants.WaveformFrameNames
WaveformDataNames = constants.WaveformDataNames
WaveformDataNamesLaTeX = constants.WaveformDataNamesLaTeX
WeightError = constants.WeightError

class Waveforms(_object):
    """
    class GWFrames::Waveforms
    =========================
      Object storing a collection of Waveform objects to be operated on uniformly.
      
      Member variables
      ----------------
        vector<Waveform> Ws
        bool CommonTimeSet
      

    """
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Waveforms, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Waveforms, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Waveforms (plural!) //.
        =======================
          Parameters
          ----------
            const int N = 0
          
          Returns
          -------
            Waveforms
          
          Description
          -----------
            Empty constructor of N empty objects.
          

        Basic copy constructor.
        =======================
          Parameters
          ----------
            const Waveforms& In
          
          Returns
          -------
            Waveforms
          

        Basic copy constructor.
        =======================
          Parameters
          ----------
            const vector<Waveform>& In
          
          Returns
          -------
            Waveforms
          

        """
        this = _GWFrames.new_Waveforms(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _GWFrames.delete_Waveforms
    __del__ = lambda self : None;
    def __getitem__(self, *args):
        """
        Parameters
        ----------
          const int i

        Returns
        -------
          const Waveform&




        Parameters
        ----------
          const int i

        Returns
        -------
          Waveform&


        """
        return _GWFrames.Waveforms___getitem__(self, *args)

    def clear(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          void


        """
        return _GWFrames.Waveforms_clear(self)

    def size(self):
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          unsigned int


        """
        return _GWFrames.Waveforms_size(self)

    def SetCommonTime(self, *args):
        """
        Interpolate to a common set of times.
        =====================================
          Parameters
          ----------
            vector<vector<double>>& Radii
            const double MinTimeStep = 0.005
            const double EarliestTime = -3e300
            const double LatestTime = 3e300
          
          Returns
          -------
            void
          

        """
        return _GWFrames.Waveforms_SetCommonTime(self, *args)

    def Extrapolate(self, *args):
        """
        Main extrapolation routine.
        ===========================
          Parameters
          ----------
            vector<vector<double>>& Radii
              Array of radii for each Waveform (first index) and each time (second
              index)
            const vector<int>& ExtrapolationOrders
              List of integers denote extrapolation orders
            const vector<double>& Omegas = vector<double>(0)
              Optional list of angular frequencies for scaling extrapolation polynomial
          
          Returns
          -------
            Waveforms
          
          Description
          -----------
            The input FiniteRadiusWaveforms are assumed to be properly scaled and
            time-retarded, and interpolated to a uniform set of retarded times. This
            function simply steps through the indices, fitting those data to
            polynomials in 1/radius, and evaluating at 0 (for infinity).
            
            The extrapolation orders can be negative. In this case, the scaled,
            time-retarded waveform at finite radius is given, where N=-1 is the
            outermost Waveform, N=-2 is the second to outermost, etc.
            
            Note that the fitting uses gsl_multifit_linear_usvd, which is GSL's fitting
            function that does NOT use column scaling (specified by the 'u' in front of
            'svd' in the function name). The basic GSL fitting function uses column
            scaling 'to improve
        the accuracy of the singular values'. However, for
            convergent series, this scaling can make all the coefficients roughly equal
            (just as the Omegas option does), which defeats the SVD.
          

        """
        return _GWFrames.Waveforms_Extrapolate(self, *args)

    def __setitem__(self, *args): return _GWFrames.Waveforms___setitem__(self, *args)
Waveforms_swigregister = _GWFrames.Waveforms_swigregister
Waveforms_swigregister(Waveforms)

class vectorW(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, vectorW, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, vectorW, name)
    __repr__ = _swig_repr
    def iterator(self): return _GWFrames.vectorW_iterator(self)
    def __iter__(self): return self.iterator()
    def __nonzero__(self): return _GWFrames.vectorW___nonzero__(self)
    def __bool__(self): return _GWFrames.vectorW___bool__(self)
    def __len__(self): return _GWFrames.vectorW___len__(self)
    def pop(self): return _GWFrames.vectorW_pop(self)
    def __getslice__(self, *args): return _GWFrames.vectorW___getslice__(self, *args)
    def __setslice__(self, *args): return _GWFrames.vectorW___setslice__(self, *args)
    def __delslice__(self, *args): return _GWFrames.vectorW___delslice__(self, *args)
    def __delitem__(self, *args): return _GWFrames.vectorW___delitem__(self, *args)
    def __getitem__(self, *args): return _GWFrames.vectorW___getitem__(self, *args)
    def __setitem__(self, *args): return _GWFrames.vectorW___setitem__(self, *args)
    def append(self, *args): return _GWFrames.vectorW_append(self, *args)
    def empty(self): return _GWFrames.vectorW_empty(self)
    def size(self): return _GWFrames.vectorW_size(self)
    def clear(self): return _GWFrames.vectorW_clear(self)
    def swap(self, *args): return _GWFrames.vectorW_swap(self, *args)
    def get_allocator(self): return _GWFrames.vectorW_get_allocator(self)
    def begin(self): return _GWFrames.vectorW_begin(self)
    def end(self): return _GWFrames.vectorW_end(self)
    def rbegin(self): return _GWFrames.vectorW_rbegin(self)
    def rend(self): return _GWFrames.vectorW_rend(self)
    def pop_back(self): return _GWFrames.vectorW_pop_back(self)
    def erase(self, *args): return _GWFrames.vectorW_erase(self, *args)
    def __init__(self, *args): 
        this = _GWFrames.new_vectorW(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args): return _GWFrames.vectorW_push_back(self, *args)
    def front(self): return _GWFrames.vectorW_front(self)
    def back(self): return _GWFrames.vectorW_back(self)
    def assign(self, *args): return _GWFrames.vectorW_assign(self, *args)
    def resize(self, *args): return _GWFrames.vectorW_resize(self, *args)
    def insert(self, *args): return _GWFrames.vectorW_insert(self, *args)
    def reserve(self, *args): return _GWFrames.vectorW_reserve(self, *args)
    def capacity(self): return _GWFrames.vectorW_capacity(self)
    __swig_destroy__ = _GWFrames.delete_vectorW
    __del__ = lambda self : None;
vectorW_swigregister = _GWFrames.vectorW_swigregister
vectorW_swigregister(vectorW)

PNWaveforms_ellMax = _GWFrames.PNWaveforms_ellMax
class PNWaveform(Waveform):
    """
    class GWFrames::PNWaveform
    ==========================
      Object for calculating a post-Newtonian Waveform with (optional) precession.
      
      Member variables
      ----------------
        vector<vector<double>> mchi1
        vector<vector<double>> mchi2
        vector<vector<double>> mOmega_orb
        vector<vector<double>> mOmega_prec
        vector<vector<double>> mL
        vector<double> mPhi_orb
      

    """
    __swig_setmethods__ = {}
    for _s in [Waveform]: __swig_setmethods__.update(getattr(_s,'__swig_setmethods__',{}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PNWaveform, name, value)
    __swig_getmethods__ = {}
    for _s in [Waveform]: __swig_getmethods__.update(getattr(_s,'__swig_getmethods__',{}))
    __getattr__ = lambda self, name: _swig_getattr(self, PNWaveform, name)
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        Parameters
        ----------
          (none)

        Returns
        -------
          PNWaveform




        Parameters
        ----------
          const PNWaveform& W

        Returns
        -------
          PNWaveform




        Parameters
        ----------
          const string& Approximant
          const double delta
          const vector<double>& chi1_i
          const vector<double>& chi2_i
          const double Omega_orb_i
          const Quaternions::Quaternion& R_frame_i = Quaternions::Quaternion(1, 0, 0, 0)
          const double PNOrder = 4.0
          double v_0 = -1.0

        Returns
        -------
          PNWaveform


        """
        this = _GWFrames.new_PNWaveform(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _GWFrames.delete_PNWaveform
    __del__ = lambda self : None;
    def chi1Mag(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          double


        """
        return _GWFrames.PNWaveform_chi1Mag(self, *args)

    def chi2Mag(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          double


        """
        return _GWFrames.PNWaveform_chi2Mag(self, *args)

    def chi1(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          const vector<double>&




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<vector<double>>&


        """
        val = _GWFrames.PNWaveform_chi1(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def chi2(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          const vector<double>&




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<vector<double>>&


        """
        val = _GWFrames.PNWaveform_chi2(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Omega_orb(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          const vector<double>&




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<vector<double>>&


        """
        val = _GWFrames.PNWaveform_Omega_orb(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Omega_prec(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          const vector<double>&




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<vector<double>>&


        """
        val = _GWFrames.PNWaveform_Omega_prec(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Omega_tot(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          vector<double>




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.PNWaveform_Omega_tot(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def L(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          const vector<double>&




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<vector<double>>&


        """
        val = _GWFrames.PNWaveform_L(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Omega_orbMag(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          double




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<double>


        """
        val = _GWFrames.PNWaveform_Omega_orbMag(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Omega_precMag(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          double




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<double>


        """
        val = _GWFrames.PNWaveform_Omega_precMag(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Omega_totMag(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          double




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<double>


        """
        val = _GWFrames.PNWaveform_Omega_totMag(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def LMag(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          double




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<double>


        """
        val = _GWFrames.PNWaveform_LMag(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def chiHat1(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          vector<double>




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.PNWaveform_chiHat1(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def chiHat2(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          vector<double>




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.PNWaveform_chiHat2(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def OmegaHat_orb(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          vector<double>




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.PNWaveform_OmegaHat_orb(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def OmegaHat_prec(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          vector<double>




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.PNWaveform_OmegaHat_prec(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def OmegaHat_tot(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          vector<double>




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.PNWaveform_OmegaHat_tot(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def LHat(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          vector<double>




        Parameters
        ----------
          (none)

        Returns
        -------
          vector<vector<double>>


        """
        val = _GWFrames.PNWaveform_LHat(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

    def Phi_orb(self, *args):
        """
        Parameters
        ----------
          const unsigned int iTime

        Returns
        -------
          double




        Parameters
        ----------
          (none)

        Returns
        -------
          const vector<double>&


        """
        val = _GWFrames.PNWaveform_Phi_orb(self, *args)
        if isinstance(val, tuple) : val = numpy.array(val) 

        return val

PNWaveform_swigregister = _GWFrames.PNWaveform_swigregister
PNWaveform_swigregister(PNWaveform)

def GetFileNamePrefix(W) :
    return W.DescriptorString() + '_' + W.FrameTypeString() + '_'
Waveform.GetFileNamePrefix = GetFileNamePrefix


def GetLaTeXDataDescription(W) :
    from GWFrames import UnknownDataType, h, hdot, Psi4
    LaTeXDataDescription = ''
    if(W.RIsScaledOut()) :
        LaTeXDataDescription = r'r\,'
    if(W.MIsScaledOut()) :
        if(W.DataType()==UnknownDataType or W.DataType()==h) :
            LaTeXDataDescription = LaTeXDataDescription + W.DataTypeLaTeXString() + r'/M'
        elif(W.DataType()==hdot) :
            LaTeXDataDescription = LaTeXDataDescription + W.DataTypeLaTeXString() # hdot is independent of M
        elif(W.DataType()==Psi4) :
            LaTeXDataDescription = LaTeXDataDescription + r'M\,' + W.DataTypeLaTeXString()
    else :
        LaTeXDataDescription = LaTeXDataDescription + W.DataTypeLaTeXString()
    return LaTeXDataDescription
Waveform.GetLaTeXDataDescription = GetLaTeXDataDescription


def OutputToNRAR(W, FileName, FileWriteMode='w') :
    """
    Output the Waveform in NRAR format.

    Note that the FileName is prepended with some descriptive
    information involving the data type and the frame type, such as
    'rhOverM_' or 'rMPsi4_'.

    """
    from h5py import File
    from os.path import basename, dirname
    from GWFrames import UnknownDataType, h, hdot, Psi4
    Group = None
    if('.h5' in FileName and not FileName.endswith('.h5')) :
        FileName,Group = FileName.split('.h5')
        FileName += '.h5'
    # Add descriptive prefix to FileName
    if(not dirname(FileName)) :
        FileName = W.DescriptorString() + '_' + basename(FileName)
    else :
        FileName = dirname(FileName) + '/' + basename(FileName)
    # Open the file for output
    try :
        F = File(FileName, FileWriteMode)
    except IOError : # If that did not work...
        print("OutputToH5 was unable to open the file '{0}'.\n\n".format(FileName))
        raise # re-raise the exception after the informative message above
    try :
        # If we are writing to a group within the file, create it
        if(Group) :
            G = F.create_group(Group)
        else :
            G = F
        # Now write all the data to various groups in the file
        G.attrs['OutputFormatVersion'] = 'GWFrames_NRAR'
        G.create_dataset("History.txt", data = W.HistoryStr() + 'OutputToNRAR(W, {0})\n'.format(FileName))
        G.attrs['FrameType'] = W.FrameType()
        G.attrs['DataType'] = W.DataType()
        G.attrs['RIsScaledOut'] = int(W.RIsScaledOut())
        G.attrs['MIsScaledOut'] = int(W.MIsScaledOut())
        for i_m in range(W.NModes()) :
            ell,m = W.LM()[i_m]
            Data_m = G.create_dataset("Y_l{0}_m{1}.dat".format(ell, m), data=[[t, d.real, d.imag] for t,d in zip(W.T(),W.Data(i_m))],
				      compression="gzip", shuffle=True)
            Data_m.attrs['ell'] = ell
            Data_m.attrs['m'] = m
    finally : # Use `finally` to make sure this happens:
        # Close the file and we are done
        F.close()
Waveform.OutputToNRAR = OutputToNRAR


def OutputToH5(W, FileName) :
    """
    Output the Waveform with all necessary information.

    Note that the FileName is prepended with some descriptive
    information involving the data type and the frame type, such as
    'rhOverM_Corotating_' or 'rPsi4_Aligned_'.

    """
    from h5py import File
    from os.path import basename, dirname
    from GWFrames import UnknownDataType, h, hdot, Psi4
    # Add descriptive prefix to FileName
    FileName = dirname(FileName) + '/' + W.GetFileNamePrefix() + basename(FileName)
    # Open the file for output
    try :
        F = File(FileName, 'w')
    except IOError : # If that did not work...
        print("OutputToH5 was unable to open the file '{0}'.\n\n".format(FileName))
        raise # re-raise the exception after the informative message above
    try :
        # Now write all the data to various groups in the file
        F.attrs['OutputFormatVersion'] = 'GWFrames_v2'
        F.create_dataset("History", data = W.HistoryStr() + 'OutputToH5(W, {0})\n'.format(FileName))
        F.create_dataset("Time", data=W.T().tolist(), compression="gzip", shuffle=True)
        if(len(W.Frame())>0) :
            F.create_dataset("Frame", data=[[r[0], r[1], r[2], r[3]] for r in W.Frame()])
        else :
            F.create_dataset("Frame", shape=())
        F.attrs['FrameType'] = W.FrameType()
        F.attrs['DataType'] = W.DataType()
        F.attrs['RIsScaledOut'] = int(W.RIsScaledOut())
        F.attrs['MIsScaledOut'] = int(W.MIsScaledOut())
        Data = F.create_group("Data")
        for i_m in range(W.NModes()) :
            ell,m = W.LM()[i_m]
            Data_m = Data.create_dataset("l{0}_m{1:+}".format(ell, m), data=W.Data(i_m),
					 compression="gzip", shuffle=True)
            Data_m.attrs['ell'] = ell
            Data_m.attrs['m'] = m
    finally : # Use `finally` to make sure this happens:
        # Close the file and we are done
        F.close()
Waveform.OutputToH5 = OutputToH5


def ReadFromH5(FileName) :
    """
    Read data from an H5 file, as output by GWFrames.
    """
    from h5py import File
    from GWFrames import Waveform
    from Quaternions import Quaternion
    from numpy import empty
    try :
        f = File(FileName, 'r')
    except IOError :
        print("ReadFromH5 could not open the file '{0}'\n\n".format(FileName))
        raise
    try :
        # Initialize the Waveform object
        W = Waveform()
        # Record the filename being read in
        W.AppendHistory("*this = GWFrames.ReadFromH5(FileName='{0}')\n".format(FileName))
        # Add the old history to the new history
        W.AppendHistory("# <previous_history>\n#" + f['History'][()].replace('\n','\n#') + "# </previous_history>\n")
        # Get the time data
        W.SetTime(f['Time'])
        # Get the frame data, converting to GWFrame.Quaternion objects
        try :
            W.SetFrame([Quaternion(r) for r in f['Frame']])
        except TypeError :
            pass # There was no frame
        # Get the descriptive items
        try :
            W.SetFrameType(int(f.attrs['FrameType']))
            W.SetDataType(int(f.attrs['DataType']))
            W.SetRIsScaledOut(bool(f.attrs['RIsScaledOut']))
            W.SetMIsScaledOut(bool(f.attrs['MIsScaledOut']))
        except KeyError :
            print("\nWarning: FrameType, DataType, RIsScaledOut, and/or MIsScaledOut were not found in '{0}'.\n".format(FileName))
        # Get list of data sets and the LM data (unsorted)
        ModeData = list(f['Data'])
        LMlist = [[f['Data'][Data_m].attrs['ell'], f['Data'][Data_m].attrs['m']] for Data_m in ModeData]
        NModes = len(LMlist)
        # Get the order of the sort by LM
        SortedIndices = sorted(range(NModes),key=lambda i : LMlist[i])
        # Initialize the data set and LM set
        Data = empty((NModes, W.NTimes()), dtype='complex128')
        LM = empty((NModes, 2), dtype='int')
        # Loop through the modes, storing them in sorted order
        for i_m in range(NModes) :
            Data[i_m] = f['Data'][ModeData[SortedIndices[i_m]]]
            LM[i_m] = LMlist[SortedIndices[i_m]]
        # Now add these data to the Waveform object
        W.SetLM(LM.tolist())
        W.SetData(Data)
    except KeyError :
        print("This H5 file appears to have not stored all the required information.\n\n")
        raise # Re-raise the exception after adding our information
    finally : # Use `finally` to make sure this happens:
        f.close()
    return W


def MonotonicIndices(T, MinTimeStep=1.e-5) :
    """
    Given an array of times, return the indices that make the array strictly monotonic.
    """
    import numpy
    Ind = range(len(T))
    Size = len(Ind)
    i=1
    while(i<Size) :
        if(T[Ind[i]]<=T[Ind[i-1]]+MinTimeStep) :
            j=0
            while(T[Ind[j]]+MinTimeStep<T[Ind[i]]) :
                j += 1
            # erase data from j (inclusive) to i (exclusive)
            Ind = numpy.delete(Ind, range(j,i))
            Size = len(Ind)
            i = j-1
        i += 1
    return Ind


def ReadFromNRAR(FileName) :
    """
    Read data from an H5 file in NRAR format.
    """
    import re
    import h5py
    from GWFrames import Waveform
    from Quaternions import Quaternion
    import numpy
    YlmRegex = re.compile(r"""Y_l(?P<L>[0-9]+)_m(?P<M>[-+0-9]+)\.dat""")
    # Initialize the Waveform object
    W = Waveform()
    # Record the filename being read in
    W.AppendHistory("*this = GWFrames.ReadFromNRAR(FileName='{0}')\n".format(FileName))
    try :
        FileName, RootGroup = FileName.rsplit('.h5', 1)
        FileName += '.h5'
    except ValueError :
        RootGroup = '' # FileName is just a file, not a group in a file
    try :
        f_h5 = h5py.File(FileName, 'r')
    except IOError :
        print("ReadFromNRAR could not open the file '{0}'\n\n".format(FileName))
        raise
    if(RootGroup) :
        f = f_h5[RootGroup]
    else :
        f = f_h5
    try :
        try :
            # Add the old history to the new history, if found
            OldHistory = f['History.txt'][()]
            W.AppendHistory("# <previous_history>\n#" + OldHistory.replace('\n','\n#') + "# </previous_history>\n")
        except KeyError :
            pass # Did not find a history
        # Get the frame data, converting to Quaternions.Quaternion objects
        try :
            W.SetFrame([Quaternion(r) for r in f['Frame']])
        except KeyError :
            pass # There was no frame data
        # Get the descriptive items
        try :
            W.SetFrameType(int(f.attrs['FrameType']))
            W.SetDataType(int(f.attrs['DataType']))
            W.SetRIsScaledOut(bool(f.attrs['RIsScaledOut']))
            W.SetMIsScaledOut(bool(f.attrs['MIsScaledOut']))
        except KeyError :
            print("\nWarning: FrameType, DataType, RIsScaledOut, and/or MIsScaledOut were not found in '{0}'.\n".format(FileName)+
                  "Using defaults.  You may want to re-set them manually.\n\n")
            W.SetFrameType(1)
            W.SetRIsScaledOut(True)
            W.SetMIsScaledOut(True)
            if('psi4' in FileName.lower()) :
                W.SetDataType(3)
            elif('hdot' in FileName.lower()) :
                W.SetDataType(2)
            elif('h' in FileName.lower()) :
                W.SetDataType(1)
        # Get the names of all the datasets in the h5 file, and check for matches
        YLMdata = [DataSet for DataSet in list(f) for m in [YlmRegex.search(DataSet)] if m]
        if(len(YLMdata)==0) :
            raise ValueError("Couldn't understand dataset names in '{0}'.".format(FileName))
        # Sort the dataset names by increasing ell, then increasing m
        YLMdata = sorted(YLMdata, key=lambda DataSet : [int(YlmRegex.search(DataSet).group('L')), int(YlmRegex.search(DataSet).group('M'))])
        # List just the ell and m numbers
        LM = sorted([[int(m.group('L')), int(m.group('M'))] for DataSet in YLMdata for m in [YlmRegex.search(DataSet)] if m])
        NModes = len(LM)
        # Get the time data (assuming all are equal)
        Wdata = f[YLMdata[0]]
        NTimes = Wdata.shape[0]
        T = Wdata[:,0]
        # Set up storage
        Re = numpy.empty((NModes, NTimes))
        Im = numpy.empty((NModes, NTimes))
        m = 0
        # Loop through, getting each mode
        for DataSet in YLMdata :
            if( not (f[DataSet].shape[0]==NTimes) ) :
                raise ValueError("The number of time steps in this dataset should be {0}; ".format(NTimes) +
                                 "it is {0} in '{1}'.".format(f[DataSet].shape[0], DataSet))
            Re[m,:] = f[DataSet][:,1]
            Im[m,:] = f[DataSet][:,2]
            m += 1
        # Make sure time is monotonic and set the data
        Indices = MonotonicIndices(T)
        BadIndices = numpy.setdiff1d(range(len(T)), Indices)
        W.SetTime(T[Indices])
        W.SetLM(LM)
        W.SetData(numpy.delete(Re, BadIndices, 1)+1j*numpy.delete(Im, BadIndices, 1))
    except KeyError :
        print("This H5 file appears to have not stored all the required information.\n\n")
        raise # Re-raise the exception after adding our information
    finally : # Use `finally` to make sure this happens:
        f_h5.close()
    return W



# This file is compatible with both classic and new-style classes.


